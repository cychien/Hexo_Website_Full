---
title: <區塊鏈技術與應用上課筆記-2> 比特幣的運作原理及安全性
date: 2018-03-09 21:53:41
tags:
author: Justin
cover: /images/house.jpg
categories:
- Blockchain
---
這一系列文章是紀錄我在“區塊鏈技術與應用”這門課中的上課所學。

## 比特幣確認交易的過程

1.  交易發起人: 廣播一筆交易到全網

2.  礦工：收集未確認交易

    礦工會把未確認的交易通通放進自己的mempool中

3.  礦工：打包交易

    1.  取出手續費較高的交易
    2.  確認交易合法性(簽名、雙花攻擊、餘額足夠)
    3.  解工作量證明

4.  礦工：寫帳or驗證

    - 第一個算出來的礦工取得記帳的權利，他會快速廣播他挖到的塊至全網
    - 其他的節點會驗證收到的塊，確認無誤後就會將那個塊接到自己的區塊鏈上

當中你可能有許多疑問，我們一個個來看。

## 如何確認交易合法性？

這是一個比較大的問題，交易合法性又包括了三個小問題：

-  如何確保你是這筆錢的擁有者，有權利花費這筆錢？
-  你是否花了同一筆錢兩次？
-  餘額是否充足？

> 針對第一點，比特幣採用**數位簽章**的方式解決身份辨識的問題

首先我們先認識一下非對稱加密、數位簽章及UTXO

### 非對稱加密

“非對稱加密”的相對就是“對稱加密”，兩者不同之處在於：

-  對稱加密：生產出一把鑰匙，用那把鑰匙進行加密，再用那把鑰匙進行解密
-  非對稱加密：生產出一“對”鑰匙(公私鑰)，用私鑰加密，再用公鑰解密

### 數位簽章

運作原理

![數位簽章](/images/digital-signature.png)

發送交易方要傳送的東西如下：

-  交易內容
-  簽名(交易內容 -> hash後的交易內容 -> 再以私鑰加密)
-  公鑰

而驗證方的工作為：

1.  將交易內容hash
2.  以公鑰解開簽名
3.  比對1和2的結果，如果一樣就代表身份無誤

交易內容之所以要hash的原因為，非對稱加密無法處理內容過大的資料

可以停下來想一下為何簽名可以做身份的確認

### UTXO

在比特幣中，交易Transaction簡寫為**TX**，而UTXO指的是Unspent Transaction Output

比特幣利用UTXO方案來記錄一筆筆的交易，而我們一般見到的多是account-based方案

accout-based方案長得如下：

Create 25 coins and credit to Alice  
Transfer 17 coins from Alice to Bob  
Transfer 8 coins from Bob to Carol  

每一條訊息都記錄著誰轉給誰的資訊，相當直觀易懂

而UTXO方案長得如下：

![UTXO](/images/UTXO.png)

一旦有output未曾出現在之後的input中，我們就視這個output為UTXO，所有UTXO的總和就是你現有的金錢總量

每個output都必須一次性的花完，如果有剩，就以“找零”的方式記到下個output中

### 交易格式與驗證

這邊就是第一個問題的解決辦法了，如果能夠懂以上的先備知識，相信也就可以懂比特幣的驗證方式。

![bitcoin-transaction](/images/bitcoin-transaction.png)

- scriptSig : <簽名> <公鑰>

    scriptSig主要是提供一種身份辨識，確保你有權利花費這筆錢

- scriptPubKey : OP_DUP OP_HASH160 < pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

    scriptPubKey你可以想像為**如果你要花這筆得到的錢，你應該通過什麼步驟**

這邊相信大家還是有點不太懂，以例子來看會比較快也比較清楚

假設Alice給了Bob 50 btc

部分交易內容如下：

```
“hash"：“aaaaa”,

...

"out":[
    "scriptPubKey" : "OP_DUP OP_HASH160 <Bob 的pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG"
]
```

input現在並不重要，因為我們假設Alice給Bob的這筆交易已經成功，並且也已通過認證，現在我們要驗證Bob究竟有沒有權利動用這50 btc

假設Bob收到錢後，發起另一筆交易，給Carol 10 btc

部分交易內容如下：

```
"in":[{
    "prev_out" : {
        "hash" : "aaaaa",
        "n" : 0
    }
},
    "scriptSig" : <Bob 的簽名> <Bob 的公鑰>
]
```

> Bob能不能花錢的關鍵就在於scriptSig，而**礦工要驗證的就是這一組scriptSig能否通過交易“aaaaa”的scriptPubKey**

想像有一個stack，裡頭先放入scriptSig再放入scriptPubKey，實際驗證情形如下：

1.  < Bob 的簽名> < Bob 的公鑰>
2.  < Bob 的簽名> < Bob 的公鑰> < Bob 的公鑰> (因為OP_DUP操作)
3.  < Bob 的簽名> < Bob 的公鑰> < Hash160(Bob 的公鑰)> (因為OP_HASH160操作)
4.  < Bob 的簽名> < Bob 的公鑰> < Hash160(Bob 的公鑰)> <Bob 的pubKeyHash>
5.  < Bob 的簽名> < Bob 的公鑰> (OP_EQUALVERIFY操作，如果前面的兩者相等就通過第一關)
6.  T (OP_CHECKSIG操作，如果簽名與公鑰有配對到(回想一下數位簽章)，就通過第二關)

接下來比較難的地方就是思考一下為何通過第一關 ＆ 第二關就代表Bob可以動用那個交易"aaaaa" output裡的錢

我自己思考後的結果是

- 通過第一關：公鑰hash相等 => 代表發款人(Alice)確實是把錢發給有這把公鑰的人(Bob)
- 通過第二關：簽名與公鑰有配對到 => 代表有這把公鑰的人確實是這把公鑰的所有人，不是盜用來的

鑰匙間的關係圖如下：

私鑰 -> 公鑰 -> hash公鑰

逆推的過程非常難，也因此可以了解到保全了私鑰，就等於保全了一切

> 針對第二個問題：你是否花了同一筆錢兩次？

比特幣無法從根本上完全阻絕雙花攻擊，只能用一些機制讓**故意執行雙花攻擊且必定成功**這件事變得很困難

### 最長鏈法則

在比特幣中，每個節點都只認同最長鏈，假如有一條鏈現在的塊高度是100，而下一秒傳進來一個塊高度105的區塊，這時候該鏈就會承認那個比較高的塊，並往前尋找那個塊之前的塊，假設如果那條新的鏈的第100區塊與現在的第100區塊不同，則舊有的塊會被取代掉，裡頭的交易吐回mempool

### POW

這時候你可能就會想，假設我一筆錢傳給分身帳戶，將含有這筆記錄的區塊鏈叫甲 ; 一筆錢傳給真正的收款人，將含有這筆記錄的區塊鏈叫乙，那我只要不停將區塊連在甲上面，那麼甲不就會是最後被承認的鏈，雙花攻擊不就完成了嗎？

比特幣因為這個原由，設計一套共識機制叫**POW**

P2P網路先天有不穩定性，因此讓大家互相溝通形成共識很難實現，而隨機選出一人寫帳，可以阻絕有人刻意操控結果的行為

但POW也面臨了一個tradeoff

- 解題時間長 (計算成本高 -> 避免女巫攻擊)
- 解題時間短 (高效能)

所以最後訂下十分鐘為解題時間，並以難度作為時間的調控

POW解的數學題如下：

> Hash(previous block hash + TXs + nonce) < target

target愈小，難度愈高

有了這個機制，即使有節點獨占全網算力70%，也只代表他有70%的機會有寫帳權，而且他要維持這樣算力的成本是非常非常驚人的

> 針對第三個問題：餘額是否充足

這個問題相對容易，去檢查餘額和花費的金額就行了

### Merkle Tree

每個塊中不只存交易本身，也會存有由眾多交易組成的merkle root

有以下功用：

- 如果今天在區塊中的某一筆交易本文被竄改，則計算出來之Merkel Root也一定不同
- Merkle tree 被用來歸納一個區塊中的所有交易，同時生成整個交易集合的數字指紋，且提供了一種校驗區塊是否存在某交易的高效途徑

## 安全隱憂

1.  雙花攻擊

2.  女巫攻擊

3.  netsplit
    挖到新區塊但是不告訴別人，如果挖的速度夠快真的變成最長的鏈，那麼就等於壟斷了所有比特幣獎勵
    ex. 中國長城

4.  Transaction malleability
    同一筆交易卻有兩個不同的hash
    
5.  Finny attack
    和雙花攻擊同樣概念，預先將有衝突的交易包入到區塊


